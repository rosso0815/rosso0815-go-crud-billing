// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: customer.sql

package db_gen

import (
	"context"
)

const customerCreate = `-- name: CustomerCreate :one
INSERT INTO Customer
	(first_Name, last_Name, street, town, remark, email, phone, ahv, alv, quellensteuer, salary_hour)
VALUES
	($1, $2, $3, $4, $5,$6, $7, $8, $9, $10, $11)
RETURNING Customer_Id
`

type CustomerCreateParams struct {
	Firstname     string  `json:"firstname"`
	Lastname      string  `json:"lastname"`
	Street        string  `json:"street"`
	Town          string  `json:"town"`
	Remark        string  `json:"remark"`
	Email         string  `json:"email"`
	Phone         string  `json:"phone"`
	Ahv           float64 `json:"ahv"`
	Alv           float64 `json:"alv"`
	Quellensteuer float64 `json:"quellensteuer"`
	Salaryhour    float64 `json:"salaryhour"`
}

func (q *Queries) CustomerCreate(ctx context.Context, db DBTX, arg CustomerCreateParams) (int, error) {
	row := db.QueryRow(ctx, customerCreate,
		arg.Firstname,
		arg.Lastname,
		arg.Street,
		arg.Town,
		arg.Remark,
		arg.Email,
		arg.Phone,
		arg.Ahv,
		arg.Alv,
		arg.Quellensteuer,
		arg.Salaryhour,
	)
	var customer_id int
	err := row.Scan(&customer_id)
	return customer_id, err
}

const customerDelete = `-- name: CustomerDelete :exec
DELETE FROM customer WHERE customer_id = $1
`

func (q *Queries) CustomerDelete(ctx context.Context, db DBTX, customerid int) error {
	_, err := db.Exec(ctx, customerDelete, customerid)
	return err
}

const customerGetById = `-- name: CustomerGetById :one
SELECT customer_id, created_at, modified_at, first_name, last_name, street, town, remark, email, phone, ahv, alv, quellensteuer, salary_hour FROM customer
WHERE customer_id = $1
`

func (q *Queries) CustomerGetById(ctx context.Context, db DBTX, customerid int) (Customer, error) {
	row := db.QueryRow(ctx, customerGetById, customerid)
	var i Customer
	err := row.Scan(
		&i.CustomerID,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.FirstName,
		&i.LastName,
		&i.Street,
		&i.Town,
		&i.Remark,
		&i.Email,
		&i.Phone,
		&i.Ahv,
		&i.Alv,
		&i.Quellensteuer,
		&i.SalaryHour,
	)
	return i, err
}

const customerUpdate = `-- name: CustomerUpdate :exec
UPDATE Customer
SET
	first_Name = $1,
	last_Name = $2,
	street = $3,
	town = $4,
	remark = $5,
	email = $6,
	phone = $7,
	ahv = $8,
	alv = $9,
	quellensteuer = $10,
	salary_hour = $11
WHERE customer_Id = $12
`

type CustomerUpdateParams struct {
	Firstname     string  `json:"firstname"`
	Lastname      string  `json:"lastname"`
	Street        string  `json:"street"`
	Town          string  `json:"town"`
	Remark        string  `json:"remark"`
	Email         string  `json:"email"`
	Phone         string  `json:"phone"`
	Ahv           float64 `json:"ahv"`
	Alv           float64 `json:"alv"`
	Quellensteuer float64 `json:"quellensteuer"`
	Salaryhour    float64 `json:"salaryhour"`
	Customerid    int     `json:"customerid"`
}

func (q *Queries) CustomerUpdate(ctx context.Context, db DBTX, arg CustomerUpdateParams) error {
	_, err := db.Exec(ctx, customerUpdate,
		arg.Firstname,
		arg.Lastname,
		arg.Street,
		arg.Town,
		arg.Remark,
		arg.Email,
		arg.Phone,
		arg.Ahv,
		arg.Alv,
		arg.Quellensteuer,
		arg.Salaryhour,
		arg.Customerid,
	)
	return err
}

const customersList = `-- name: CustomersList :many
SELECT customer_id FROM customer
`

func (q *Queries) CustomersList(ctx context.Context, db DBTX) ([]int, error) {
	rows, err := db.Query(ctx, customersList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var customer_id int
		if err := rows.Scan(&customer_id); err != nil {
			return nil, err
		}
		items = append(items, customer_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const customersListBySearch = `-- name: CustomersListBySearch :many
SELECT customer_id FROM customer
		where
			first_name ilike '%' || $1::text || '%'
		or
 			last_name ilike '%' || $1::text || '%'
		or
 			street ilike '%' || $1::text || '%'
		or
 			town ilike '%' || $1::text || '%'
		or
 			remark ilike '%' || $1::text || '%'
		ORDER BY customer_id DESC
		LIMIT
			$3
		OFFSET
 			$2
`

type CustomersListBySearchParams struct {
	Search    string `json:"search"`
	PageCount int64  `json:"page_count"`
	PageSize  int64  `json:"page_size"`
}

func (q *Queries) CustomersListBySearch(ctx context.Context, db DBTX, arg CustomersListBySearchParams) ([]int, error) {
	rows, err := db.Query(ctx, customersListBySearch, arg.Search, arg.PageCount, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var customer_id int
		if err := rows.Scan(&customer_id); err != nil {
			return nil, err
		}
		items = append(items, customer_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const customersListCount = `-- name: CustomersListCount :one
SELECT count(*) FROM customer
where
	first_name ilike '%' || $1::text || '%'
or
	last_name ilike '%' || $1::text || '%'
`

func (q *Queries) CustomersListCount(ctx context.Context, db DBTX, search string) (int64, error) {
	row := db.QueryRow(ctx, customersListCount, search)
	var count int64
	err := row.Scan(&count)
	return count, err
}
